#' @name disturb
#' @title disturb
#' @description Causes mortality in a specific region of the landscape.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape.
#' @param prob a number between 0 and 1 representing probability of death.
#' @param grid_size an integer defining max grid coordinates for X or Y.
#' @param xlim a vector of min and max X coordinates for the region where distrubance will occur.
#' @return pop with reductions based on location of individuals and probability of death.
#' @examples
#' pop <- populate_landscape(); disturb(pop)
#' qplot(X, Y, data = pop, xlim = c(0, 100))
#' qplot(X, Y, data = disturb(pop), xlim = c(0, 100))
#' @export
disturb <- function(
  pop,
  prob = 1,
  xlim = c(50, 100),
  grid_size = 100
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "X" %in% colnames(pop),
    "Y" %in% colnames(pop),
    is.numeric(prob),
    between(prob, 0, 1),
    is.numeric(grid_size),
    grid_size%%1==0,
    is.numeric(xlim),
    between(xlim[1], 0, grid_size),
    between(xlim[2], 0, grid_size)
  )
  # subset plants in area to be disturbed
  disturbed <- pop %>% filter(
    between(X, xlim[1], xlim[2])
  )
  undisturbed <- pop %>% filter(
    !between(X, xlim[1], xlim[2])
  )
  # create disturbance
  if(nrow(disturbed) > 0){
    disturbed <- disturbed %>% survive(1 - prob)
  }
  return(
    bind_rows(
      disturbed,
      undisturbed
    )
  )
}

#' @name reproduce
#' @title reproduce
#' @description Creates new seeds based on adult population.
#' @author Rose McKeon
#' @param adults population dataframe that contains all adults of a particular generation.
#' @param N_ovules number of ovules each adult will create (default = 100).
#' @param pollen_range integer representing the dispersal rage of pollen default = 100 so, as grid_size default is also 100, all plants in the landscape will be used as potential pollen donors for all ovules. When < 100 only plants within range will be used as pollen donors, so alleles movement will be restricted into regions of the landscape.
#' @param fertilisation_prob number between 0 and 1 representing probability fertilisation between gametes is successful.
#' @param uneven_matching_prob number between 0 and 1 representing fertlisation_prob applied to zygotes with gametes whose ploidy levels do not match (default = 0.1 so triploids are rare but do occur).
#' @param selfing_polyploid_prob number between 0 and 1 representing fertilisation_prob applied to polyploids which are selfing (default = , so polyploids can always self)..
#' @param selfing_diploid_prob number between 0 and 1 representing fertilisation_prob applied to diploids which are selfing (default = 0, so diploids can never self).
#' @param triploid_mum_prob number between 0 and 1 representing fertilisation_prob applied to zygotes with triploid mums (default = 0.1 to reduce the number of seeds that triploid plants produce).
#' @param generation integer representing the generation of simulation in which offspring appear. Used to prefix individual $ID (default = 1).
#' @param ploidy_prob number between 0 and 1 representing the probability that genome duplication will occur (default = 0.01).
#' @param genome_size integer representing size of genome, ie: number of loci (default = 2).
#' @param grid_size integer representing the size of the landscape grid. Used to ensure pollen range does not exceed size of the landscape and reduces computation when pollen range is at maximum, ie: equal to grid size (default = 100).
#' @examples
#' reproduce(adults)
#' @export
reproduce <- function(
  adults,
  N_ovules = 25,
  pollen_range = 100,
  fertilisation_prob = .5,
  uneven_matching_prob = .1,
  selfing_polyploid_prob = 1,
  selfing_diploid_prob = 0,
  triploid_mum_prob = .1,
  generation = 1,
  ploidy_prob = .01,
  genome_size = 2,
  grid_size = 100
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(adults),
    "life_stage" %in% colnames(adults),
    all(adults$life_stage == 2),
    is.numeric(
      c(
        N_ovules,
        pollen_range,
        fertilisation_prob,
        uneven_matching_prob,
        selfing_polyploid_prob,
        selfing_diploid_prob,
        triploid_mum_prob,
        generation,
        genome_size,
        ploidy_prob,
        grid_size
      )
    ),
    between(
      c(
        fertilisation_prob,
        uneven_matching_prob,
        selfing_polyploid_prob,
        selfing_diploid_prob,
        triploid_mum_prob,
        ploidy_prob
      ),
      0, 1
    ),
    c(
      N_ovules,
      pollen_range,
      generation,
      genome_size,
      grid_size
    )%%1==0,
    between(pollen_range, 0, grid_size)
  )
  # prepare a new table with room for ovules and genomes
  adults_out <- create_pop() %>% add_column(
    genome = list(),
    ovules = list()
  )
  for(adult in 1:nrow(adults)){
    # update the table for every plant as ovules are created
    adults_out <- bind_rows(
      adults_out,
      create_ovules(
        adults[adult, ], N_ovules
      )
    )
  }
  message(
    "  ", nrow(adults_out) * N_ovules, " ovules created: ",
    N_ovules, " ovules per adult."
  )
  # do we need to split population into pools?
  if(pollen_range < grid_size){
    message("  -----------")
    # pollination occurs within pools of plants
    # which are in fertilisation range, so let's organise
    # adults by landscae cell to give groups of mums.
    adults_nested <- adults_out %>% nest_by_location()
    # and create an empty zygote dataframe to add to
    zygotes <- create_zygotes()
    # then loop through the mums to find dads in range
    for(populated_cell in 1:nrow(adults_nested)){
      # subset the ovules to be fertilised
      mums <- adults_nested[populated_cell, ]
      # and pollen donors that can fertilise them
      dads <- get_pollen_donors(
        mums$X,
        mums$Y,
        adults_nested,
        pollen_range,
        grid_size
      )
      # now create the zygotes
      these_zygotes <- create_zygotes(
        mums %>% unnest(),
        dads %>% unnest(),
        ploidy_prob,
        fertilisation_prob,
        uneven_matching_prob,
        selfing_polyploid_prob,
        selfing_diploid_prob,
        triploid_mum_prob
      )
      # store some output
      message("  ", nrow(these_zygotes), " zygotes created in cell: ", mums$X, ", ", mums$Y, ".")
      zygotes <- bind_rows(
        zygotes,
        these_zygotes
      )
    }
    message("  -----------")
  } else {
    # the whole landscape is in range
    # so don't bother with extra computation
    zygotes <- create_zygotes(
      adults_out, # mums
      adults_out, # dads
      ploidy_prob,
      fertilisation_prob,
      uneven_matching_prob,
      selfing_polyploid_prob,
      selfing_diploid_prob,
      triploid_mum_prob
    )
  }
  if(nrow(zygotes) > 0){
    return(format_zygotes_as_seeds(zygotes, generation))
  } else {
    return(F)
  }
}

#' @name get_pollen_donors
#' @title get_pollen_donors
#' @description Filters a population dataframe by X and Y values within range of X and Y to give a subset of possible pollen donors for ovules that exist in X  and Y, based on pollen range and grid size (to account for landscape wrapping).
#' @author Rose McKeon
#' @param X integer representing the X location of ovules.
#' @param Y integer representing the Y location of ovules.
#' @param adults dataframe of individual adults who may or may not be pollen donors.
#' @param pollen_range integer between 0 and grid_size - 1 representing the dispersal range of pollen (default = 99).
#' @param grid_size positive integer representing the size of the landscape grid (default = 100).
#' @return dataframe subset of adults.
#' @examples
#' # samples IDS of adults within 10 cell range of coordinate 1, 1.
#' get_pollen_donors(1, 1, adults, 10)
#' @export
get_pollen_donors <- function(
  X = NULL, Y = NULL,
  adults = NULL,
  pollen_range = 99,
  grid_size = 100
){
  # check we have the right parameters
  stopifnot(
    is.numeric(X),
    X%%1==0,
    is.numeric(Y),
    Y%%1==0,
    is.data.frame(adults),
    "X" %in% colnames(adults),
    "Y" %in% colnames(adults),
    is.numeric(pollen_range),
    pollen_range%%1==0,
    is.numeric(grid_size),
    grid_size%%1==0,
    between(pollen_range, 0, grid_size - 1)
  )
  max_coord <- grid_size - 1
  # X range with landscape wrapping
  max_X <- X + pollen_range
  min_X <- X - pollen_range
  if(max_X > max_coord){
    # we need to filter those with X upto grid_size
    valid_X <- seq(X, max_coord)
    # AND some more on the other side of the landscape
    valid_X <- c(valid_X, seq(0, max_X - grid_size))
  } else {
    valid_X <- seq(X, max_X)
  }
  if(min_X < 0){
    # we need to filter those with X down to 1
    valid_X <- c(valid_X, seq(X, 0))
    # AND some more on the other size of the landscape
    valid_X <- c(valid_X, seq(grid_size, grid_size + min_X))
  } else {
    valid_X <- c(valid_X, seq(X, min_X))
  }

  # Y range with landscape wrapping
  max_Y <- Y + pollen_range
  min_Y <- Y - pollen_range
  if(max_Y > max_coord){
    # we need to filter those with Y upto grid_size
    valid_Y <- seq(Y, max_coord)
    # AND some more on the other side of the landscape
    valid_Y <- c(valid_Y, seq(0, max_Y - grid_size))
  } else {
    valid_Y <- seq(Y, max_Y)
  }
  if(min_Y < 0){
    # we need to filter those with Y down to 1
    valid_Y <- c(valid_Y, seq(Y, 0))
    # AND some more on the other size of the landscape
    valid_Y <- c(valid_Y, seq(grid_size, grid_size + min_Y))
  } else {
    valid_Y <- c(valid_Y, seq(Y, min_Y))
  }
  # return subset of adults based on valid locations
  return(adults %>% filter(X %in% valid_X & Y %in% valid_Y))
}

#' @name create_zygotes
#' @title create_zygotes
#' @description Takes a dataframe containing an adult population that has ovules already created and returns a dataframe of successful fertilisations as progenitor ID pairs. Assumes all ovules receive pollen but applies a probability of fertlisation success to simulate some failure via mechanisms such as pollen loss etc.
#' @author Rose McKeon
#' @param mums dataframe of mums, adults with ovules already created using create_ovules().
#' @param dads dataframe of pollen donors (dads) adults who are within pollen_range of mums, found using get_pollen_donors().
#' @param ploidy_prob number between 0 and 1 which represents the probability that genome duplication will occur (default = 0.01).
#' @param fertilisation_prob number between 0 and 1 representing the probability that fertlisation will be successful (default = 0.5).
#' @param uneven_matching_prob number between 0 and 1 representing fertlisation_prob applied to zygotes with gametes whose ploidy levels do not match (default = 0.1 so triploids are rare but do occur).
#' @param selfing_polyploid_prob number between 0 and 1 representing fertilisation_prob applied to polyploids which are selfing (default = , so polyploids can always self)..
#' @param selfing_diploid_prob number between 0 and 1 representing fertilisation_prob applied to diploids which are selfing (default = 0, so diploids can never self).
#' @param triploid_mum_prob number between 0 and 1 representing fertilisation_prob applied to zygotes with triploid mums (default = 0.1 to reduce the number of seeds that triploid plants produce).
#' @return dataframe of paired ovules and pollen represented as progenitor IDs in columns $mum and $dad. Location data in columns $X and $Y maintained from ovule locations.
#' @export
create_zygotes <- function(
  mums = NULL,
  dads = NULL,
  ploidy_prob = .01,
  fertilisation_prob = .5,
  uneven_matching_prob = .1,
  selfing_polyploid_prob = 1,
  selfing_diploid_prob = 0,
  triploid_mum_prob = .1
){
  if(is.null(mums) | is.null(dads)){
    # output a blank zygote dataframe
    return(
      tibble(
        mum = character(),
        X = numeric(),
        Y = numeric(),
        maternal_ploidy = numeric(),
        dad = character(),
        paternal_ploidy = numeric(),
        maternal_duplication = logical(),
        paternal_duplication = logical(),
        maternal_gamete_ploidy = numeric(),
        paternal_gamete_ploidy = numeric(),
        fertilisation_prob = numeric(),
        matching_gamete_ploidy = logical(),
        selfing = logical(),
        selfing_polyploid = logical(),
        selfing_diploid = logical()
      )
    )
  } else {
    # output zygotes based on mums and dads
    # make sure we have the right kind of parameters
    stopifnot(
      is.data.frame(mums),
      nrow(mums) > 0,
      "ovules" %in% colnames(mums),
      "ID" %in% colnames(mums),
      is.data.frame(dads),
      nrow(dads) > 0,
      "ID" %in% colnames(dads),
      is.numeric(fertilisation_prob),
      between(fertilisation_prob, 0, 1),
      is.numeric(ploidy_prob),
      between(ploidy_prob, 0, 1),
      is.numeric(uneven_matching_prob),
      between(uneven_matching_prob, 0, 1),
      is.numeric(selfing_polyploid_prob),
      between(selfing_polyploid_prob, 0, 1),
      is.numeric(selfing_diploid_prob),
      between(selfing_diploid_prob, 0, 1),
      is.numeric(triploid_mum_prob),
      between(triploid_mum_prob, 0, 1)
    )
    # gather all the ovules together as a dataframe
    # so additional zygote data can be added as a new columns
    zygotes <- do.call(
      "bind_rows",
      mums %>% pull(ovules)
    )
    # pair pollon donors with ovules with replacement
    # to simulate many pollen grains produced by each plant
    zygotes$dad <- sample(dads$ID, nrow(zygotes), replace = T)
    # include paternal ploidy level
    zygotes$paternal_ploidy <- dads$ploidy[match(zygotes$dad, dads$ID)]
    # decide where genome duplication occurs by unreduced gametes
    # paternal and maternal duplication events are independent
    zygotes$maternal_duplication <- rbinom(nrow(zygotes), 1, ploidy_prob * .333) == 1
    zygotes$paternal_duplication <- rbinom(nrow(zygotes), 1, ploidy_prob * .333) == 1
    # decide where genome duplication occurs by nondisjunction of early embryos
    # paternal and maternal duplication events co-occur.
    nondisjunction <- rbinom(nrow(zygotes), 1, ploidy_prob * .333) == 1
    zygotes <- zygotes %>% mutate(
      maternal_duplication = replace(
        maternal_duplication,
        which(nondisjunction),
        TRUE
      ),
      paternal_duplication = replace(
        paternal_duplication,
        which(nondisjunction),
        TRUE
      )
    )
    # calculate actual gamete ploidy levels
    # default to half that of parent
    zygotes$maternal_gamete_ploidy <- zygotes$maternal_ploidy / 2
    zygotes$paternal_gamete_ploidy <- zygotes$paternal_ploidy / 2
    # modify if triploid parent so gametes either 1 or 2, not 1.5
    # (gametes created by triploids are either haploid or diploid)
    maternal_triploids <- zygotes$maternal_ploidy == 3
    paternal_triploids <- zygotes$paternal_ploidy == 3
    zygotes <- zygotes %>% mutate(
      maternal_gamete_ploidy = replace(
        maternal_gamete_ploidy,
        which(maternal_triploids),
        sample(1:2, 1)
      ),
      paternal_gamete_ploidy = replace(
        paternal_gamete_ploidy,
        which(paternal_triploids),
        sample(1:2, 1)
      )
    )
    # modify if duplication occurred
    zygotes <- zygotes %>% mutate(
      maternal_gamete_ploidy = replace(
        maternal_gamete_ploidy,
        which(maternal_duplication),
        maternal_ploidy[which(maternal_duplication)]
      ),
      paternal_gamete_ploidy = replace(
        paternal_gamete_ploidy,
        which(paternal_duplication),
        paternal_ploidy[which(paternal_duplication)]
      )
    )
    # modify if gamete ploidy > 2 to cap ploidy level at 4
    # amd set duplication to FALSE as alleles will now need to be sampled
    # (only happens if polyploid parents undergo duplication)
    maternal_over_2 <- zygotes$maternal_gamete_ploidy > 2
    paternal_over_2 <- zygotes$paternal_gamete_ploidy > 2
    zygotes <- zygotes %>% mutate(
      maternal_duplication = replace(
        maternal_duplication,
        which(maternal_over_2),
        FALSE
      ),
      paternal_duplication = replace(
        paternal_duplication,
        which(paternal_over_2),
        FALSE
      ),
      maternal_gamete_ploidy = replace(
        maternal_gamete_ploidy,
        which(maternal_over_2),
        2
      ),
      paternal_gamete_ploidy = replace(
        paternal_gamete_ploidy,
        which(paternal_over_2),
        2
      )
    )
    # simulate some failure
    # fertilisation_prob modified depending on specific circumstances
    zygotes$fertilisation_prob <- fertilisation_prob
    # like gamete ploidy levels that don't match
    zygotes$matching_gamete_ploidy <- zygotes$maternal_gamete_ploidy == zygotes$paternal_gamete_ploidy
    # or when selfing is occuring
    zygotes$selfing <- zygotes$mum == zygotes$dad
    zygotes$selfing_polyploid <- zygotes$selfing & zygotes$maternal_ploidy > 2
    zygotes$selfing_diploid <- zygotes$selfing & zygotes$maternal_ploidy == 2
    # or when mums are triploid
    triploid_mum <- zygotes$maternal_ploidy == 3
    # make replacements
    zygotes <- zygotes %>% mutate(
      fertilisation_prob = replace(
        fertilisation_prob,
        which(!matching_gamete_ploidy),
        uneven_matching_prob
      ),
      fertilisation_prob = replace(
        fertilisation_prob,
        which(selfing_polyploid),
        selfing_polyploid_prob
      ),
      fertilisation_prob = replace(
        fertilisation_prob,
        which(selfing_diploid),
        selfing_diploid_prob
      ),
      fertilisation_prob = replace(
        fertilisation_prob,
        which(triploid_mum),
        triploid_mum_prob
      )
    )
    # return randomly reduced data based on fertilisation probabilities
    # to simulate some weighted failure
    return(zygotes %>% survive(zygotes$fertilisation_prob))
  }
}

#' @name format_zygotes_as_seeds
#' @title format_zygotes_as_seeds
#' @description Takes a dataframe containing zygote information (as created by create_zygotes) and returns them formatted as seeds. The result is a population dataframe with all the zygote information nested in the $genome list-column; ready to be filled with actual genomes at a later stage.
#' @author Rose McKeon
#' @param zygotes dataframe of zygotes with progenitor IDs in $mum and $dad columns, as well as maternal location information in $X and $Y.
#' @param generation integer used to prefix IDs of new individual seeds.
#' @return zygotes updated with $ID, $life_stage, $size and $genome (containing temporary lineage details used later to create real genomes).
#' @export
format_zygotes_as_seeds <- function(
  zygotes = NULL,
  generation = 1
){
  # make sure we have the right parameters
  stopifnot(
    is.data.frame(zygotes),
    nrow(zygotes) > 0,
    "mum" %in% colnames(zygotes),
    "dad" %in% colnames(zygotes),
    is.numeric(generation),
    generation%%1==0
  )
  # add other usual population data
  seeds <- zygotes %>% add_column(
    ID = paste0(generation, "_", 1:nrow(zygotes)),
    life_stage = as.integer(0),
    size = as.integer(0)
  )
  # make sure the seeds have ploidy info
  seeds$ploidy <- zygotes$maternal_gamete_ploidy + zygotes$paternal_gamete_ploidy
  # nest secondary zygote data as temp genome
  seeds <- seeds %>%
    group_by(ID, X, Y, life_stage, size, ploidy) %>%
    nest(.key = "genome")

  # output
  message("  Zygotes formatted as seeds.")
  return(seeds)
}

#' @name fill_seeds_with_genomes
#' @title fill_seeds_with_genomes
#' @description Takes seed data (with linegae details nested in $genome) and replaces this column with real genomes; alleles sampled from parent genomes.
#' @param seeds a data frame containing seeds.
#' @param parents a data frame containing possible parents.
#' @param mutation_rate number between 0 and 1 representing the rate of allele mutation (default = 0.001).
#' @param genome_size The size of the genome.
#' @return seeds updated so $genome is replaced with real genomes.
#' @export
fill_seeds_with_genomes <- function(
  seeds = NULL,
  parents = NULL,
  mutation_rate = 0.001,
  genome_size = 2
){
  # save zygote info before updating seeds
  zygotes <- seeds %>% unnest()
  # name parent genomes by parent ID
  # this means we can get 1 genome returned by referencing
  # list item name instead of filtering for row by plant ID
  # which may contain duplicates (either due to cloning or dormancy)
  names(parents$genome) <- parents$ID
  blank_genome <- create_genome(genome_size)
  genomes <- apply(
    seeds, 1,
    sample_genome,
    parents, blank_genome, genome_size
  )
  message("") # cause a line break after genome filling
  # do mutation
  genomes <- lapply(
    genomes, mutate_genome, mutation_rate
  )
  # swap temp genomes for new ones
  seeds$genome <- genomes
  # output
  return(seeds)
}


#' @name mutate_genome
#' @title mutate_genome
#' @description Mutate allele values of genome based on mutaion rate.
#' @author Rose McKeon
#' @param genome a dataframe containing the genome of an individual
#' @param mutation_rate a number representing the probability that mutation will occur. Used by rbinom to randomly choose which alleles are mutated.
#' @return The genome data with allele values of mutated alleles updated if mutation occurred. Allele values are random uniform numbers between 0 and 100, chosen in the same way as a new allele in create_genome().
#' @export
mutate_genome <- function(genome = NULL, mutation_rate = .001){
  # make sure we have the right parameters
  stopifnot(
    is.data.frame(genome),
    "allele" %in% colnames(genome),
    "locus" %in% colnames(genome),
    "value" %in% colnames(genome),
    is.numeric(mutation_rate)
  )
  # decide which alelles mutate
  mutations <- rbinom(nrow(genome), 1, mutation_rate) == 1
  # then mutate them
  if(any(mutations)){
    mutations <- which(mutations)
    genome <- genome %>% mutate(
      value = replace(
        value,
        mutations,
        runif(length(mutations), 0, 100)
      )
    )
  }
  return(genome)
}

#' @name choose_alleles
#' @title choose_alleles
#' @description Chooses an allele, or N number of alleles from a locus.
#' @author Rose McKeon
#' @param locus A numerical vector of allele values for the same locus. The genome of an individual which is grouped by locus and nested is passed to this function by sample_alleles using apply which makes every row of the genome in this format into a vector.
#' @param N integer representing the number of alleles to sample, ie: the ploidy level (default = 1 for haploid gametes).
#' @return a random allele sampled from x.
#' @export
choose_alleles <- function(locus, N = 1){
  locus$data %>% pull(value) %>% sample(N, replace = T)
}

#' @name create_ovules
#' @title create_ovules
#' @description Adds a new list-column $ovules to an individual plant which contains ovules as parent IDs.
#' @author Rose McKeon
#' @param plant A single row of a population dataframe as generated by populate_landscape. Should also be an adult (life stage == 2).
#' @param N integer representing the number of ovules to make.
#' @return The updated plant dataframe.
#' @export
create_ovules <- function(
  plant,
  N = 500
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(plant),
    "genome" %in% colnames(plant),
    "life_stage" %in% colnames(plant),
    all(plant$life_stage == 2),
    is.numeric(N),
    N%%1==0
  )
  # Create a dataframe of ovules to populate gametes
  # Each referes to parent ID which will be used to
  # sample genomes if fertilised.
  ovules <- tibble(
    mum = rep(plant$ID, N),
    X = rep(plant$X, N),
    Y = rep(plant$Y, N),
    maternal_ploidy = rep(plant$ploidy, N)
  )
  # add the gametes to the parent plant
  plant <- plant %>% add_column(
    ovules = list(ovules)
  )
  return(plant)
}

#' @name compete
#' @title compete
#' @description Makes sure number of adults that survive in a cell to reproduce is constrained to K.
#' @author Rose McKeon
#' @param competitors row of nested dataframe where competitors are grouped by location into list-column $plants.
#' @param K integer representing K, the carrying capacity (max population size) of any given cell (default = 1, so plants compete over grid squares and only 1 per square can survive).
#' @param beneficial_trait the name of a column which contains trait values that should give a competative advatage, eg: "size".
#' @return list where $adults = K winners sampled from competitors and $juveniles = juveniles with those in the same location as winnning adults removed.
#' @export
compete <- function(competitors, K = 1, beneficial_trait = NULL){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(competitors$plants),
    nrow(competitors$plants) >= K,
    is.numeric(K),
    K%%1==0,
    K > 0
  )
  X <- competitors$X
  Y <- competitors$Y
  competitors <- competitors$plants
  message("  ", nrow(competitors), " plants compete in cell: ", X, ", ", Y, ".")
  if(!is.null(beneficial_trait)){
    # get the traits
    traits <- competitors[[beneficial_trait]]
    # turn them into vals between 0 and 1
    probs <- traits/sum(traits)
    # use these in sampling the winner
    winners <- sample_n(competitors, K, prob = probs)
  } else {
    # just pick the winner at random
    winners <- sample_n(competitors, K)
  }
  # make sure we have the right amount of winners
  stopifnot(
    nrow(winners) == K
  )
  return(winners)
}

#' @name get_those_not_outcompeted
#' @title Which individuals are not challenged by adults?
#' @author Rose McKeon
#' @description Reduces population based on locations of adults. Used when those where adults become established cannot survive (100 percent mortality).
#' @usage get_those_not_outcompeted(adults, pop)
#' @param adults a data frame containing adults.
#' @param pop data frame containing individuals, ie: seeds/juveniles.
#' @param message String containing log to output before giving number of removals (default = "Individuals outcompeted by adults: ").
#' @return dataframe passed as inds modified with removals based on X and Y coordinates of adults.
get_those_not_outcompeted <- function(
  adults,
  pop,
  message = "Individuals outcompeted by adults: "
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(adults),
    "X" %in% colnames(adults),
    "Y" %in% colnames(adults),
    is.data.frame(pop),
    "X" %in% colnames(pop),
    "Y" %in% colnames(pop),
    is.character(message)
  )
  removals <- apply(
    adults, 1, # by row
    FUN = function(adult, pop){
      # find the indices for those in the same location as each adult
      return(which(pop$X == adult$X & pop$Y == adult$Y))
    },
    pop
  )
  removals <- unique(combine(removals))
  message("  ", message, length(removals))
  # then remove those juveniles
  return(pop[-removals, ])
}


#' @name grow
#' @title grow
#' @description Change size and number of plants based on growth rate determined via loci of genome.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param type character string defining type of growth. Can be "individuals" or "clones".
#' @param adult_size number representing size threshold for becoming an adult. Only used in individual growth, not clonal (default = NULL).
#' @return pop with updated sizes and life stages.
#' @export
grow <- function(
  pop = NULL,
  type = "individuals",
  adult_size = NULL
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "size" %in% colnames(pop),
    "genome" %in% colnames(pop),
    is.character(type),
    type %in% c("individuals", "clones")
  )
  if(type == "individuals"){
    stopifnot(
      is.numeric(adult_size)
    )
    # do some growing
    pop$size <- round(pop$size * pop$growth_rate, 3)
    # resubset based on new size
    juveniles <- pop %>% filter(
      size < adult_size
    )
    adults <- pop %>% filter(
      size >= adult_size
    )
    # and update life stages
    if(nrow(adults) > 0){
      adults <- adults %>% mutate(life_stage = 2)
    }
    # then recombine
    pop <- bind_rows(juveniles, adults)
  } else {
    # do some cloning
    # only size is changed as clones are genetically identical
    # and remain in the same landscape cell
    clones <- pop %>% mutate(
      size = 1, # clones are same size as new juveniles,
      life_stage = 1
    )
    # make sure clones are in adjacent cells
    clones <- clones %>% move(grid_size, always_away = T)
    pop <- bind_rows(pop, clones)
  }
  return(pop)
}

#' @name germinate
#' @title germinate
#' @description Changes some seeds within a dataframe into juveniles, based on the locations of adults as well as the probability of germination.
#' @author Rose McKeon
#' @param seeds a population dataframe that contains only seeds, as generated by populate_landscape(). These are the seeds that will germinate according to prob.
#' @param adults a population dataframe that contains only adults, as generated by populate_landscape(). If an adult is already established in a landscape cell, seeds in that cell will not germinate.
#' @param prob a number between 0 and 1 representing probability of germination.
#' @return seeds with some individuals having updated $life_stage and $size, both of 1.
#' @export
germinate <- function(
  seeds = NULL,
  adults = NULL,
  prob = .5
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(seeds),
    "life_stage" %in% colnames(seeds),
    "size" %in% colnames(seeds),
    nrow(seeds) > 0,
    all(seeds$life_stage == 0),
    is.numeric(prob),
    between(prob, 0, 1)
  )
  still_seeds <- NULL
  # do extra steps if there are adults
  if(!is.null(adults)){
    stopifnot(
      is.data.frame(adults)
    )
    if(nrow(adults) > 0){
      stopifnot(
        "life_stage" %in% colnames(adults),
        all(adults$life_stage == 2),
        "X" %in% colnames(seeds),
        "Y" %in% colnames(seeds),
        "X" %in% colnames(adults),
        "Y" %in% colnames(adults)
      )
      # stop redundant germinations on cells with adults
      seeds <- get_those_not_outcompeted(
        adults, seeds, "Seeds unable to germinate because of established adults: "
      )
      # results <- check_germination(seeds, adults)
      # if(results$matches){
      #   seeds <- results$will_germinate
      #   still_seeds <- results$wont_germinate
      #   message(
      #     "  Seeds unable to germinate because of established adults: ",
      #     nrow(still_seeds)
      #   )
      # }
    }
  }
  # do germination by updating life stages
  seeds$life_stage <- rbinom(nrow(seeds), 1, prob)
  # make sure we have all failed germinations
  still_seeds <- bind_rows(
    still_seeds,
    seeds %>% filter(life_stage == 0)
  )
  # subset new juveniles and increase their size
  juveniles <- seeds %>%
    filter(life_stage == 1) %>%
    mutate(size = 1)
  # return everything so the model can decide the fate of ungerminated seeds
  return(bind_rows(still_seeds, juveniles))
}

#' @name survive
#' @title survive
#' @description Reduces population data based on probability of survival.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param prob a number between 0 and 1 representing probability of survival (default = 1, all are very likely to survive).
#' @param inbreeding_sensitivity number between 0 and 1 representing the strength of inbreeding. 0 = no effect and 1 is maximum effect. Checking for identical alleles at the specified inbreeding locus is used as a proxy for having homozygous deleterious alleles. When this happens survival chances are modified according to inbreeding sensitivity (default = 0, so inbreeding is ignored unless set).
#' @return pop minus deaths
#' @export
survive <- function(pop, prob = 1, inbreeding_sensitivity = 0){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(prob),
    between(prob, 0, 1),
    is.numeric(inbreeding_sensitivity),
    between(inbreeding_sensitivity, 0, 1)
  )
  if(inbreeding_sensitivity > 0){
    # create vector of probabilities
    prob <- pop %>%
      select(inbreeding) %>%
      mutate(
        inbreeding = replace(
          inbreeding,
          which(inbreeding),
          prob * (1 - inbreeding_sensitivity)
        ),
        inbreeding = replace(
          inbreeding,
          which(!inbreeding),
          prob
        )
      ) %>%
      pull(inbreeding)
  }

  # decide which plants die
  deaths <- rbinom(nrow(pop), 1, prob) == 0
  if(!length(which(deaths)) == 0){
    # only attempt removals if there are deaths
    pop <- pop[-which(deaths), ]
  }
  return(pop)
}

#' @name hard_select
#' @title hard_select
#' @description hard selection based on trait values. Large trait values give higher survival probabilities.
#' @author Rose McKeon
#' @param pop A population dataframe
#' @param trait A character string matching a column name which contains trait values.
#' @param Z a constant used to turn trait values into probabilities.
#' @param inbreeding_sensitivity number between 0 and 1 representing the strength of inbreeding. 0 = no effect and 1 is maximum effect. Checking for identical alleles at the specified inbreeding locus is used as a proxy for having homozygous deleterious alleles. When this happens survival chances are modified according to inbreeding sensitivity (default = 0, so inbreeding is ignored unless set).
#' @return pop reduced based on survival probabilities created from trait values.
#' @export
hard_select <- function(
  pop,
  trait,
  Z = 0.001,
  inbreeding_sensitivity = 0
){
  # make sure we have the right parameters
  stopifnot(
    is.data.frame(pop),
    is.character(trait),
    trait %in% colnames(pop),
    is.numeric(inbreeding_sensitivity),
    between(inbreeding_sensitivity, 0, 1)
  )
  # get the trait values in size order
  trait_values <- pop[[trait]] %>% sort()
  # calculate probability of survival
  prob <- 1 - exp(-Z * trait_values)

  # check for need to modify based on inbreeding
  if(inbreeding_sensitivity > 0){
    # add probabilities to inbreeding data
    inbreeding <- pop %>%
      select(inbreeding) %>%
      mutate(
        survival = prob
      )

    # modify where inbreeding disadvantage occurs
    prob <- inbreeding %>%
      mutate(
        survival = replace(
          survival,
          which(inbreeding),
          survival * (1 - inbreeding_sensitivity)
        )
      ) %>%
      pull(survival)
  }

  return(survive(pop, prob))
}

#' @name move
#' @title move
#' @description updates coordinate variables of a population dataframe as generated by populate_landscape(), ie: should be nested by plant. Movement has wrapping boundaries depending on grid size.
#' @author Rose McKeon
#' @param pop population dataframe nested by plant
#' @param grid_size integer, defines edges at which point movements wrap to the opposite side.
#' @param always_away logical value which determines if current location may or may not be used as final destination (default = FALSE, so it can be).
#' @param range maximum distance movement can be from starting point. Used to create a vector of possible movements by which to adjust the X and Y coordinates, ie: -range:range (default = 1).
#' @return pop with adjusted X and Y for every row.
#' @examples
#' pop <- populate_landscape()
#' move(pop)
#' @export
move <- function(pop, grid_size = 100, always_away = FALSE, range = 1){
  # error handling
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(c(grid_size, range)),
    c(grid_size, range)%%1==0,
    is.logical(always_away),
    between(range, 0, grid_size - 1)
  )
  # save original pop data
  start <- pop
  # define movement range to sample from
  # made this explicit as mutate method of movement
  # didn't like replacement values based on X or Y
  # (ended up with vectors instead of single numbers).
  movement <- -range:range
  # make the movement
  finish <- make_movement(start, movement, grid_size)
  # see if we need to worry about destination
  if(always_away){
    # make sure destination can't match start
    results <- check_destination(start, finish)
    while(results$matches){
      # message("moving again...")
       moved <- make_movement(results$move_again, movement, grid_size)
       finish <- bind_rows(
         moved, results$the_rest
       )
       results <- check_destination(start, finish)
    }
    finish <- results$pop
  }
  return(finish)
}

#' @name check_destination
#' @title check_destination
#' @description Checks locations of individuals in start against those in finish. Returns finish split into those that did and did not match their original start positions.
#' @author Rose McKeon
#' @param start a population data frame with $X and $Y columns defining location.
#' @param finish a population data frame of the same individuals as start, with $X and $Y columns defining location.
#' @return list with $matches as logical T/F. If F: $pop = finish. If T: $move_again = finish that didn't move and $the_rest = finsh that did move.
#' @export
check_destination <- function(start, finish){
  # check for matches
  same_X <- which(start$X == finish$X)
  if(length(same_X) > 0){
    # we have some matches so need to check Ys too
    same_Y <- which(start$Y == finish$Y)
    if(length(same_Y) > 0){
      # there might be some that are both the same
      same_both <- same_X[which(same_X %in% same_Y)]
      # return split data if required
      if(length(same_both) > 0){
        # because we found matches
        return(
          list(
            matches = T,
            move_again = finish[same_both, ],
            the_rest = finish[-same_both, ]
          )
        )
      }
    }
  }
  # no matches
  return(list(matches = F, pop = finish))
}

#' @name check_germination
#' @title check_germination
#' @description Checks locations of seeds against those of adults. Returns seeds split into those that could and could not germinate based on the presence of adults.
#' @author Rose McKeon
#' @param seeds a population data frame with $X and $Y columns defining location, containing only seeds.
#' @param adults a population data frame with $X and $Y columns defining location, containing only adults.
#' @return list with $matches as logical T/F. If F: $will_germinate = seeds. If T: $wont_germinate = seeds that are located where adults are established. $will_germinate = seeds that are located where no adults are established.
#' @export
check_germination <- function(seeds, adults){
  # check for matches
  same_X <- which(seeds$X %in% adults$X)
  if(length(same_X) > 0){
    # we have some matches so need to check Ys too
    same_Y <- which(seeds$Y %in% adults$Y)
    if(length(same_Y) > 0){
      # there might be some that are both the same
      same_both <- same_X[which(same_X %in% same_Y)]
      # return split data if required
      if(length(same_both) > 0){
        # because we found matches
        return(
          list(
            matches = T,
            wont_germinate = seeds[same_both, ],
            will_germinate = seeds[-same_both, ]
          )
        )
      }
    }
  }
  # no matches
  return(list(matches = F, will_germinate = seeds))
}


#' @name make_movement
#' @title make_movement
#' @description updates coordinate variables of a population dataframe as generated by populate_landscape(), ie: should be nested by plant. Movement has wrapping boundaries depending on grid size.
#' @author Rose McKeon
#' @param pop population dataframe nested by plant
#' @param movement vector of adjustment values which will be added to X and Y values to give new coordinates. Values from movement are sampled at random to give directionless random movement.
#' @param grid_size integer, defines edges at which point movements wrap to the opposite side.
#' @return pop with adjusted X and Y for every row.
#' @export
make_movement <- function(pop, movement = NULL, grid_size = 100){
  # error handling
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "X" %in% colnames(pop),
    "Y" %in% colnames(pop),
    is.numeric(grid_size),
    grid_size%%1==0,
    is.numeric(movement)
  )
  # make the movement for each seed different
  N <- nrow(pop)
  Xmoves <- sample(movement, size = N, replace = T)
  Ymoves <- sample(movement, size = N, replace = T)
  pop$X <- pop$X + Xmoves
  pop$Y <- pop$Y + Ymoves
  # make sure boundaries wrap
  # check for values that are too small
  Xnegative <- which(pop$X < 0)
  Ynegative <- which(pop$Y < 0)
  # if we find some do mutations
  if(any(length(Xnegative) > 0 | length(Ynegative) > 0)){
    pop <- pop %>% mutate(
      X = replace(
        X,
        Xnegative, # in positions where this happens
        grid_size + X[Xnegative] # add the negative value found to the grid size
      ),
      Y = replace(
        Y,
        Ynegative, # in positions where this happens
        grid_size + Y[Ynegative] # add the negative value found to the grid size
      )
    )
  }
  # check for values that are too big
  max_coord <- grid_size - 1
  Xover <- which(pop$X > max_coord)
  Yover <- which(pop$Y > max_coord)
  # if we find some do mutations
  if(any(length(Xover) > 0 | length(Yover) > 0)){
    pop <- pop %>% mutate(
      X = replace(
        X,
        Xover, # in positions where this happens
        X[Xover] - grid_size # minus the grid size from the high value found
      ),
      Y = replace(
        Y,
        Yover, # in positions where this happens
        Y[Yover] - grid_size # minus the grid size from the high value found
      )
    )
  }
  return(pop)
}

#' @name populate_landscape
#' @title populate_landscape
#' @description Populates the landscape grid with seeds that have random genomes and random locations, by returning a filled population dataframe of said individuals.
#' @author Rose McKeon
#' @param pop_size integer value representing number of starting seeds (default = 100).
#' @param grid_size integer value representing the size of the landscape grid (default = 100).
#' @param genome_size integer value representing the size of the genome (default = 2).
#' @param sim integer representing the current simulation number (default = 1).
#' @param ploidy_growth_benefit A number between 0 and 1 that represents the proportion by which being polyploid improves growth rate (default = 1, full benefit).
#' @param growth_rate_loci a numeric vector of positive integers (eg: 1 or 1:5) which represents the locus/loci to use for the trait growth rate (default = 1).
#' @param max_growth_rate A number representing the maximum rate which can be output no matter the genes (default = 2, so individuals can never more than double in size in a generation).
#' @return list of individuals and their relevant data objects (location and genome)
#' @examples
#' populate_landscape(100, 10)
populate_landscape <- function(
  pop_size = 100,
  grid_size = 100,
  genome_size = 2,
  sim = 1,
  ploidy_growth_benefit = 1,
  growth_rate_loci = 1,
  max_growth_rate = 2
){
  # error handling
  stopifnot(
    is.numeric(
      c(
        pop_size,
        grid_size,
        genome_size,
        sim,
        growth_rate_loci,
        max_growth_rate
      )
    ),
    c(
      pop_size,
      grid_size,
      genome_size,
      sim,
      growth_rate_loci
    )%%1==0
  )
  # setup population
  pop <- create_pop(pop_size, grid_size, sim)
  # group by all columns
  pop <- pop %>%
    group_by(
      ID, X, Y, life_stage, size, ploidy, gen, sim
    )
  # so nesting creates empty genome list-column
  pop <- pop %>% nest(
    .key = "genome"
  )
  # add unique random genomes
  for(individual in 1:pop_size){
    pop$genome[[individual]] <- create_genome(genome_size)
  }
  # so now we can
  # calculate growth rates
  pop$growth_rate <- sapply(
    pop$genome, get_growth_rate, ploidy_growth_benefit, growth_rate_loci, max_growth_rate
  )
  # and check for inbreeding
  pop$inbreeding <- sapply(
    pop$genome, get_inbreeding_value
  )
  # return updated population data
  return(pop)
}


#' @name nest_by_location
#' @title nest_by_location
#' @description Groups population dataframe by coordinates X and Y and nests all other data in list-column $plants. Arranged by X and Y.
#' @author Rose McKeon
#' @param pop population data frame containing X and Y columns.
#' @return updated pop.
#' @examples
#' nest_by_location(populate_landscape())
#' @export
nest_by_location <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "X" %in% colnames(pop),
    "Y" %in% colnames(pop)
  )
  # then group and nest pop by coordinates
  return(
    pop %>%
      group_by(X, Y) %>%
      nest(.key = "plants") %>%
      arrange(X, Y)
  )
}

#' @name create_pop
#' @title create_pop
#' @description Makes sure the population structure is always the same. Can be used to return an empty tibble (with no parameters supplied), or a generated population (if both parameters supplied).
#' @author Rose McKeon
#' @param pop_size the number of rows to populate dataframe with.
#' @param grid_size the upper limit of landscape coordinates.
#' @param sim integer representing the current simulation number.
#' @return Either an empty population dataframe with all required columns, or a filled population dataframe depending on supplied parameters.
#' @examples
#' create_pop()
#' create_pop(100, 10)
#' @export
create_pop <- function(pop_size = NULL, grid_size = NULL, sim = 1){
  if(!is.null(pop_size) & !is.null(grid_size)){
    # make sure we have numbers
    stopifnot(
      is.numeric(pop_size),
      pop_size%%1==0,
      is.numeric(grid_size),
      grid_size%%1==0,
      is.numeric(sim),
      sim%%1==0
    )
    max_coord <- grid_size - 1
    # generate starting population
    pop <- tibble(
      X = sample(0:max_coord, pop_size, replace = T),
      Y = sample(0:max_coord, pop_size, replace = T),
      ID = paste0("0_", as.character(1:pop_size)),
      life_stage = as.integer(0),
      size = as.integer(0),
      ploidy = as.integer(2),
      gen = as.integer(1),
      sim = as.integer(sim)
    )
    return(pop)
  } else {
    # create empty table
    return(
      tibble(
        X = integer(),
        Y = integer(),
        ID = character(),
        life_stage = integer(),
        size = double(),
        ploidy = integer(),
        gen = integer(),
        sim = integer()
      )
    )
  }
}

#' @name create_genome
#' @title create_genome
#' @description Creates diploid genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of loci in genome
#' @return Data frame containing a diploid genome, with 2 alleles for each locus and number of loci determined by genome_size. Data in long format with $allele and $locus as factors and $value being a random uniform number between 0 and 100.
#' @examples
#' create_genome()
#' @export
create_genome <- function(
  genome_size = 10
){
  stopifnot(
    is.numeric(genome_size),
    genome_size%%1==0
  )
  # create random genome
  genome <- tibble(
    allele = c(
      rep(1, genome_size),
      rep(2, genome_size)
    ),
    locus = c(
      rep(1:genome_size, 2)
    ),
    value = runif(
      genome_size*2, 0, 100
    )
  )
  return(genome)
}

#' @name sample_genome
#' @title sample_genome
#' @description Takes a vector of seed data that has parent IDs in the genome instead of alleles, and returns a genome of alleles which has been sampled from both parents.
#' @author Rose McKeon
#' @param seed vector of seed data with mum and dad columns nested in genome list-column.
#' @param parents population dataframe containing all possible parents.
#' @param genome Default genome as output by create_genome().
#' @return genome with value filled by sampling parent genomes, defined by parent IDs in seed.
#' @export
sample_genome <- function(
  seed,
  parents = NULL,
  genome = NULL,
  genome_size = 10
){
  # extract zygote details of seed
  zygote <- seed$genome
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(zygote),
    "mum" %in% colnames(zygote),
    "dad" %in% colnames(zygote),
    is.data.frame(parents),
    "ID" %in% colnames(parents),
    "genome" %in% colnames(parents),
    is.data.frame(genome),
    "allele" %in% colnames(genome),
    "locus" %in% colnames(genome),
    "value" %in% colnames(genome),
    is.numeric(genome_size),
    genome_size%%1==0
  )

  # extract parents of seed
  parent_IDs <- zygote %>%
    select(mum, dad) %>%
    gather() %>%
    pull(value)

  alleles <- tibble(
    locus = numeric(),
    value = numeric()
  )
  # get the genome of every parent
  for(parent in 1:length(parent_IDs)){
    # if multiple ramets available only one genome should
    # be returned as all are named the same
    parent_genome <- parents$genome[[parent_IDs[parent]]]
    stopifnot(
      is.data.frame(parent_genome),
      "allele" %in% colnames(parent_genome),
      "locus" %in% colnames(parent_genome),
      "value" %in% colnames(parent_genome)
    )
    # see if we have mum or dad
    if(parent == 1){
      # we have mum
      duplication <- zygote$maternal_duplication
      gamete_ploidy <- zygote$maternal_gamete_ploidy
    } else if(parent == 2){
      # we have dad
      duplication <- zygote$paternal_duplication
      gamete_ploidy <- zygote$paternal_gamete_ploidy
    }
    # make sure gamete ploidy has a number (needed for sampling)
    # and duplication has logical values to check for
    stopifnot(
      is.numeric(gamete_ploidy),
      !is.na(gamete_ploidy),
      is.logical(duplication)
    )
    # does duplication occur?
    if(duplication){
      # duplicate entire parent genome
      these_alleles <- parent_genome %>%
        select(locus, value)
      # make sure locus is numeric for binding
      these_alleles$locus <- as.numeric(these_alleles$locus)
    } else {
      # nest so every locus is on a row
      parent_genome <- parent_genome %>%
        group_by(locus) %>%
        nest()
      # then sample an allele/s from each locus
      # making sure to create the right ploidy level
      # according to gamete_ploidy
      these_alleles <- tibble(
        locus = rep(
          1:genome_size,
          each = gamete_ploidy
        ),
        value = apply(
          parent_genome, 1,
          choose_alleles,
          gamete_ploidy
        ) %>% reduce(c)
      )
    }
    # store alleles for debugging
    if(parent == 1){
      these_alleles_1 <- these_alleles
      gamete_ploidy_1 <- gamete_ploidy
    }
    # combine with other parent's alleles
    alleles <- bind_rows(
      alleles,
      these_alleles
    )
  }
  # now both parents have contributed genes
  # what ploidy level is the seed suppossed to be?
  ploidy_lvl <- zygote$maternal_gamete_ploidy + zygote$paternal_gamete_ploidy
  # nesting by locus
  alleles <- alleles %>%
    group_by(locus) %>%
    nest()
  # so we can see how many alleles belong to each
  # and create data for the allele column
  allele_labels <- lapply(
    alleles$data,
    FUN = function(locus){
      1:nrow(locus)
  }) %>% reduce(c)
  # unnest to complete the genome
  # and add the allele label data
  genome <- alleles %>%
    unnest() %>% mutate(
      allele = allele_labels
    )
  # let's make sure we built it right
  stopifnot(
    ploidy_lvl == nlevels(as.factor(genome$allele))
  )
  # now we can handle output
  # check for normal diploid zygotes
  if(ploidy_lvl == 2){
    message("~", appendLF = F)
  } else {
    # ploidy happened either by duplication or by
    # parental ploidy making non-haploid gametes
    message(ploidy_lvl, appendLF = F)
  }
  return(genome)
}
