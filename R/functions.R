#' @name grow
#' @details Change size of plants based on growth rate determined via loci of genome.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param loci a vector of locus IDs for the alleles that define growth rate.
#' @return pop with updated sizes.
grow <- function(pop, loci = 1:10){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop) |
    is.numeric(loci)
  )
  # decide how much plants grow
  growth_rates <- numeric()
  for(i in 1:nrow(pop)){
    growth_rates[i] <- pop$genome[[i]][loci, ] %>% select(
      -locus
    ) %>% sum() / 10000
  }
  # store the growth rates and do some growing
  pop <- pop %>% add_column(
    growth_rate = growth_rates
  )
  pop$size <- pop$size * pop$growth_rate
  return(pop)
}

#' @name germinate
#' @details Change life stage from seed to seedling based on probability.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of germination.
#' @return pop with updated life stages.
germinate <- function(pop, prob = .5){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop) |
    is.numeric(prob) |
    between(prob, 0, 1)
  )
  # decide which seeds germinate
  pop$life_stage <- rbinom(nrow(pop), 1, prob)
  return(pop)
}


#' @name survive
#' @details Reduces population data based on probability of survival.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of survival.
#' @return pop minus deaths
survive <- function(pop, prob = 1){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop) |
    is.numeric(prob) |
    between(prob, 0, 1)
  )
  # decide which plants survive
  survivors <- rbinom(nrow(pop), 1, prob)
  survivors <- pop[-which(survivors == 0), ]
  return(survivors)
}

#' @name move
#' @details updates coordinate variables of a population dataframe as generated by populate_landscape(), ie: should be nested by plant. Movement has wrapping boundaries depending on grid size.
#' @author Rose McKeon
#' @param pop population dataframe nested by plant
#' @param grid_size integer, defines edges at which point movements wrap to the opposite side.
#' @return pop with adjusted X and Y for every row.
#' @usage pop <- populate_landscape(); pop; move(pop);
move <- function(pop, grid_size = 100){
  # error handling
  stopifnot(
    is.data.frame(pop) |
    is.numeric(range) |
    range%%1==0 |
    is.numeric(grid_size) |
    grid_size%%1==0
  )
  # define movement range to sample from
  # made this explicit as mutate method of movement
  # didn't like replacement values based on X or Y
  # (ended up with vectors instead of single numbers).
  movement <- -1:1
  # make the movement
  pop <- pop %>% mutate(
    X = X + sample(movement, size = 1),
    Y = Y + sample(movement, size = 1)
  )
  # make sure boundaries wrap
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X < 1), # only where this is true
      grid_size
    ),
    Y = replace(
      Y,
      which(Y < 1), # only where this is true
      grid_size
    )
  )
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X > grid_size), # only where this is true
      1
    ),
    Y = replace(
      Y,
      which(Y > grid_size), # only where this is true
      1
    )
  )
  return(pop)
}

#' @name populate_landscape
#' @details Populates the landscape grid with individuals
#' @author Rose McKeon
#' @param pop_size integer value for number of starting individuals
#' @param grid_size integer value for size of landscape grid
#' @return list of individuals and their relevant data objects (location and genome)
#' @usage populate_landscape(100, 100)
populate_landscape <- function(
  pop_size = 100,
  grid_size = 100,
  genome_size = 100
){
  # error handling
  stopifnot(
    is.numeric(pop_size) |
    pop_size%%1==0 |
    is.numeric(grid_size) |
    grid_size%%1==0 |
    is.numeric(genome_size) |
    genome_size%%1==0
  )
  # setup population
  pop <- tibble(
    ID = 1:pop_size,
    X = sample(1:grid_size, 100, replace = T),
    Y = sample(1:grid_size, 100, replace = T),
    life_stage = as.integer(0),
    size = as.integer(0)
  )
  pop <- nest_by_plant(pop)
  # add unique genomes
  for(i in 1:pop_size){
    pop$genome[[i]] <- create_genome(genome_size)
  }
  # add density info
  pop <- nest_by_location(pop)
  # return population nested at plant level
  return(unnest(pop))
}


#' @name nest_by_location
#' @details Reorganises population dataframe generated within populate_landscape() so that it is further nested by landscape cell and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame with nested genomes
#' @return Dataframe grouped and nested by coordinates, arranged by population density in descending order.
#' @usage nest_by_location(populate_landscape())
nest_by_location <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(is.data.frame(pop))
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    # either with N
    pop <- pop %>% group_by(
      X, Y, N
    )
  } else {
    # or without
    pop <- pop %>% group_by(
      X, Y
    )
  }
  # nest by location
  pop <- pop %>% nest(
    .key = "plants"
  )
  # then create or recalculate N to include density tally
  pop$N <- pop$plants %>%
    map("ID") %>%
    lengths
  # and sort by density
  pop <- pop %>%
    arrange(desc(N))
  return(pop)
}

#' @name nest_by_plant
#' @details Reorganises population dataframe generated within populate_landscape() so that it is nested by plant ID and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame without nested genomes
#' @return Dataframe grouped by individual parameters with nested genomes.
#' @usage nest_by_location(populate_landscape())
nest_by_plant <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(is.data.frame(pop))
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    pop <- pop %>% group_by(
      ID, X, Y, N, life_stage, size
    )
  } else {
    pop <- pop %>% group_by(
      ID, X, Y, life_stage, size
    )
  }
  # collapse by plant grouping
  # to make genome data nested in list-column
  pop <- pop %>% nest(
    .key = "genome"
  )
  return(pop)
}

#' @name create_genome
#' @details Creates dipload genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of alleles in genome
#' @return data frame of length genome_size with 2 columns representing alelle pairs.
#' @usage create_genome()
create_genome <- function(genome_size = 100){
  return(tibble(
    locus = 1:genome_size,
    allele_1 = runif(genome_size, 0, 100),
    allele_2 = runif(genome_size, 0, 100)
  ))
}
