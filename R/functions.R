# functions for the model

#' @name apply_mortality
#' @details Reduces a population list based on probability of death.
#' @author Rose McKeon
#' @param X a list containing population data as generated by populate_landscape().
#' @param probability a number between 0 and 1 representing probability of death.
#' @return X minus deaths
apply_mortality <- function(X, probability = 1){
  # make sure we have a list
  stopifnot(is.list(X))
  # make sure we have numbers
  stopifnot(is.numeric(probability))
  # decide which plants die
  death <- sample(1:100, size = length(X), replace = T)
  death <- probability * 100 > death
  # return X minus the deaths
  out <- X[-which(death)]
  out
}

#' @name find_coordinates
#' @details Takes the population list and applies a function to the elements that contain location coordinates.
#' @author Rose McKeon
#' @param X a list containing poplation data generated by populate_landscape()
#' @param .f a function to apply to the coordinates
#' @param ... parameters to pass to .f
#' @return a list in the same format as X but with adjustments specified by .f made to coordinates.
find_coordinates <- function(X, .f, ...){
  # make sure we have a list
  stopifnot(is.list(X))
  # and only affect coordinates
  coordinates <- c("X_coord", "Y_coord")
  out <- X %>% lmap_at(coordinates, .f, ...)
  out
}

#' @name move
#' @details Takes a list containing a number (ie: a coordinate) and alters it based on range. Numbers conatined in X will be added to a random number, sampled from the vector -range:range.
#' @author Rose McKeon
#' @param X a list of 1 containing a coordinate.
#' @param range maximum dispersal distance.
#' @return a list in the same format as X containing the adjusted coordinate.
#' @usage
#' # change the number 5 by adding a random number sampled from -1:1
#' move(list(X = 5), 1)
#' # change all nested elements named "X_coord" and "Y_coord" of individuals created by populate_landscape() by adding a random number sampled from -1:1
#' lapply(populate_landscape(), find_coordinates, move, 1)
move <- function(X, range = 1, grid_size = 100){
  # make sure we have a list
  stopifnot(is.list(X))
  # and a number for range
  stopifnot(is.numeric(range))
  # define the range to sample from
  movement <- -range:range
  # make the movement
  new_coord <- X[[1]] + sample(movement, size = 1, replace = T)
  # make sure boundaries wrap
  if(new_coord < 0){
    new_coord <- grid_size + (1 + new_coord)
  } else if(new_coord > grid_size){
    new_coord <- -1 + (new_coord - grid_size)
  }
  # return the coordinate in a list with the same names
  out <- list()
  out[[names(X)]] <- new_coord
  return(out)
}

#' @name populate_landscape
#' @details Populates the landscape grid with individuals
#' @author Rose McKeon
#' @param pop_size integer value for number of starting individuals
#' @param grid_size integer value for size of landscape grid
#' @return list of individuals and their relevant data objects (location and genome)
#' @usage populate_landscape(100, 100)
populate_landscape <- function(pop_size = 100, grid_size = 100){
  # error handling
  stopifnot(is.numeric(pop_size) & is.numeric(grid_size))
  if(!pop_size%%1==0 | !grid_size%%1==0){
    stop("Please make sure neither pop_size or grid_size contain decimals.")
  }
  # setup landscape vector
  grid <- 1:grid_size
  # setup population with locations and genomes
  pop <- list()
  for(i in 1:pop_size){
    ID <- paste0("plant_", i)
    pop[[ID]]$X_coord <- sample(grid, 1)
    pop[[ID]]$Y_coord <- sample(grid, 1)
    pop[[ID]]$genome <- create_genome()
  }
  return(pop)
}

#' @name create_genome
#' @details Creates dipload genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of alleles in genome
#' @return data frame of length genome_size with 2 columns representing alelle pairs.
#' @usage create_genome()
create_genome <- function(genome_size = 100){
  return <- data.frame(
    A1 = runif(genome_size, 0, 100),
    A2 = runif(genome_size, 0, 100)
  )
}