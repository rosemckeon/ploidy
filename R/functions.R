#' @name disturb
#' @details Causes mortality in a specific region of the landscape.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape.
#' @param prob a number between 0 and 1 representing probability of death.
#' @param grid_size an integer defining max grid coordinates for X or Y.
#' @param xlim a vector of min and max X coordinates for the region where distrubance will occur.
#' @return pop with reductions based on location of individuals and probability of death.
#' @usage pop <- populate_landscape(); disturb(pop)
#' @usage qplot(X, Y, data = pop, xlim = c(0, 100))
#' @usage qplot(X, Y, data = disturb(pop), xlim = c(0, 100))
disturb <- function(
  pop,
  prob = 1,
  xlim = c(50, 100),
  grid_size = 100
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "X" %in% colnames(pop),
    "Y" %in% colnames(pop),
    is.numeric(prob),
    between(prob, 0, 1),
    is.numeric(grid_size),
    grid_size%%1==0,
    is.numeric(xlim),
    between(xlim[1], 0, grid_size),
    between(xlim[2], 0, grid_size)
  )
  # subset plants in area to be disturbed
  disturbed <- pop %>% filter(
    between(X, xlim[1], xlim[2])
  )
  undisturbed <- pop %>% filter(
    !between(X, xlim[1], xlim[2])
  )
  # create disturbance
  if(nrow(disturbed) > 0){
    disturbed <- disturbed %>% survive(1 - prob)
  }
  return(
    bind_rows(
      disturbed,
      undisturbed
    )
  )
}


#' @name reproduce
#' @details creates new seeds based on adult population.
#' @author Rose McKeon
#' @param pop population dataframe as generated by populate_landscape, subset by life stage = 2 (adults).
#' @param N_gametes number of male and female gametes each adult will create.
#' @param pollen_finds_ova_prob number between 0 and 1 representing probability that pollen released will find ova.
#' @param total_pop_size integer representing whole population size (ie: including seeds and seedlings). Used to give new seeds IDs.
reproduce <- function(
  adults,
  N_gametes = 100,
  fertilisation_prob = .5,
  generation = 1,
  genome_size = 10,
  ploidy_prob = .01,
  mutation_rate = .001
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(adults),
    "life_stage" %in% colnames(adults),
    all(adults$life_stage == 2),
    is.numeric(N_gametes),
    N_gametes%%1==0,
    is.numeric(fertilisation_prob),
    between(fertilisation_prob, 0, 1),
    is.numeric(generation),
    generation%%1==0,
    is.numeric(genome_size),
    genome_size%%1==0,
    is.numeric(ploidy_prob),
    between(ploidy_prob, 0, 1),
    is.numeric(mutation_rate)
  )
  # prepare a new table with room for ovules and genomes
  adults_out <- create_pop() %>% add_column(
    genome = list(),
    ovules = list()
  )
  for(adult in 1:nrow(adults)){
    # update the table for every plant as ovules are created
    adults_out <- bind_rows(
      adults_out,
      create_ovules(
        adults[adult, ], N_gametes
      )
    )
  }
  message(
    "  ", nrow(adults_out) * N_gametes, " ovules created: ",
    N_gametes, " ovules per adult."
  )
  # prepare a new tibble for zygotes
  zygotes <- tibble(
    mum = character(),
    X = numeric(),
    Y = numeric(),
    dad = character()
  )
  # pollination occurs within pools of plants which are in fertilisation range
  # (currently this occurs within a single cell)
  adults_out <- adults_out %>% nest_by_location()
  for(location in 1:nrow(adults_out)){
    # update the zygote data for every reproductive pool
    zygotes <- bind_rows(
      zygotes,
      create_zygotes(
        adults_out$plants[location][[1]], fertilisation_prob
      )
    )
  }
  message("  ", nrow(zygotes), " zygotes created.")
  if(nrow(zygotes) > 0){
    # make sure all the new seeds have genetic info
    #tic("  Creating seeds")
    seeds <- create_seeds(
      zygotes, adults, generation, genome_size, ploidy_prob, mutation_rate
    )
    #toc()
    return(seeds)
  } else {
    return(F)
  }
}

#' @name create_zygotes
#' @details Takes a dataframe containing an adult population that has ovules already created and returns a dataframe of successful fertilisations as progenitor ID pairs. Assumes all ovules receive pollen but applies a probability of fertlisation success to simulate some failure via mechanisms such as pollen loss etc.
#' @author Rose McKeon
#' @param adults dataframe of adults (with ovules already created using create_ovules) who are within fertlisation range of one another.
#' @param prob number between 0 and 1 representing the probability that fertlisation will be successful.
#' @return dataframe of paired ovules and pollen represented as progenitor IDs in columns $mum and $dad. Location data in columns $X and $Y maintained from ovule locations.
create_zygotes <- function(adults, prob = .5){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(adults),
    nrow(adults) > 0,
    "ovules" %in% colnames(adults),
    "ID" %in% colnames(adults),
    is.numeric(prob),
    between(prob, 0, 1)
  )
  # gather all the ovules together as a dataframe
  # so paternal IDs can be added as a new column
  zygotes <- do.call(
    "bind_rows",
    adults %>% pull(ovules)
  )
  # pair pollon donors with ovules
  # with replacement to simulate many pollen grains produced by each plant
  zygotes$dad <- sample(adults$ID, nrow(zygotes), replace = T)
  # return randomly reduced data to simulate some failure
  return(zygotes %>% survive(prob))
}

#' @name create_seeds
#' @details Takes a dataframe containing zygote information (as created by create_zygotes) and returns a population dataframe in the format of that created by create_pop for which each zygote is now represented as a seed and has a genome which has been sampled from both parents, may have undergone genome duplication and may also have had alleles which have been mutated.
#' @author Rose McKeon
#' @param zygotes dataframe of zygotes with progenitor IDs in $mum and $dad columns, as well as maternal location information in $X and $Y.
#' @param parents population dataframe containing all possible parents, complete with genetic information from which to sample.
#' @param generation integer used to prefix IDs of new individual seeds.
#' @param genome_size integer representing genome size of population.
#' @param ploidy_prob number between 0 and 1 which represents the probability that genome duplication will occur.
#' @param mutation_rate number between 0 and 1 which represents the probability that any given allele will mutate.
#' @return dataframe of paired ovules and pollen represented as progenitor IDs in columns $mum and $dad. Location data in columns $X and $Y maintained from ovule locations.
create_seeds <- function(
  zygotes,
  parents,
  generation = 1,
  genome_size = 10,
  ploidy_prob = .01,
  mutation_rate = .001
){
  # make sure we have the right parameters
  stopifnot(
    is.data.frame(zygotes),
    is.data.frame(parents),
    nrow(zygotes) > 0,
    nrow(parents) > 0,
    "mum" %in% colnames(zygotes),
    "dad" %in% colnames(zygotes),
    "genome" %in% colnames(parents),
    is.numeric(generation),
    generation%%1==0,
    is.numeric(genome_size),
    genome_size%%1==0,
    is.numeric(ploidy_prob),
    between(ploidy_prob, 0, 1),
    is.numeric(mutation_rate)
  )
  message("  Creating seeds takes longer...")
  # add other usual population data
  seeds <- zygotes %>% add_column(
    ID = paste0(generation, "_", 1:nrow(zygotes)),
    life_stage = as.integer(0),
    size = as.integer(0)
  )
  # nest parent IDs as temp genomes
  seeds <- seeds %>% nest("mum", "dad", .key = "genome")
  # name parent genomes by parent ID
  # ramets have duplicate IDs, this means we can
  # get 1 genome returned by referencing list item name
  # instead of filtering for row by plant ID
  names(parents$genome) <- parents$ID
  blank_genome <- create_genome(genome_size)
  # create all the genomes
  genomes <- apply(
    seeds, 1,
    sample_genome,
    parents, blank_genome, genome_size, ploidy_prob
  )
  # do mutation
  genomes <- lapply(
    genomes, mutate_genome, mutation_rate
  )
  # swap temp genomes for new ones
  seeds$genome <- genomes
  message("  ", nrow(seeds), " zygotes became seeds.")
  return(seeds)
}

#' @name mutate_genome
#' @details Mutate allele values of genome based on mutaion rate.
#' @author Rose McKeon
#' @param genome a dataframe containing the genome of an individual
#' @param mutation_rate a number representing the probability that mutation will occur. Used by rbinom to randomly choose which alleles are mutated.
#' @return The genome data with allele values of mutated alleles updated if mutation occurred. Allele values are random uniform numbers between 0 and 100, chosen in the same way as a new allele in create_genome().
mutate_genome <- function(genome = NULL, mutation_rate = .001){
  # make ure we have the right parameters
  stopifnot(
    is.data.frame(genome),
    "allele" %in% colnames(genome),
    "locus" %in% colnames(genome),
    "value" %in% colnames(genome),
    is.numeric(mutation_rate)
  )
  # decide which alelles mutate
  mutations <- rbinom(nrow(genome), 1, mutation_rate) == 1
  # then mutate them
  if(any(mutations)){
    mutations <- which(mutations)
    genome <- genome %>% mutate(
      value = replace(
        value,
        mutations,
        runif(length(mutations), 0, 100)
      )
    )
    message(
      rep("  *Mutation occurred*\n", length(mutations)),
      appendLF = F
    )
  }
  return(genome)
}

#' @name choose_alleles
#' @details Chooses an allele from a locus.
#' @author Rose McKeon
#' @param x A vectorised row of a dataframe containing the genome of an individual which is grouped by locus and nested.
#' @return a random allele sampled from x.
choose_alleles <- function(genome){
  genome$data %>% pull(value) %>% sample(1)
}

#' @name create_ovules
#' @details Adds a new list-column $ovules to an individual plant which contains ovules as parent IDs.
#' @author Rose McKeon
#' @param plant A single row of a population dataframe as generated by populate_landscape. Should also be an adult (life stage == 2).
#' @param N integer representing the number of ovules to make.
#' @return The updated plant dataframe.
create_ovules <- function(
  plant,
  N = 500
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(plant),
    "genome" %in% colnames(plant),
    "life_stage" %in% colnames(plant),
    all(plant$life_stage == 2),
    is.numeric(N),
    N%%1==0
  )
  # Create a dataframe of ovules to populate gametes
  # Each referes to parent ID which will be used to
  # sample genomes if fertilised.
  ovules <- tibble(
    mum = rep(plant$ID, N),
    X = rep(plant$X, N),
    Y = rep(plant$Y, N)
  )
  # add the gametes to the parent plant
  plant <- plant %>% add_column(
    ovules = list(ovules)
  )
  return(plant)
}

#' @name pop_control
#' @details Randomly reduces population size of landscape cells based on carrying capacity (maximum number of plants per cell).
#' @author Rose McKeon
#' @param pop poplation dataframe nested by location.
#' @param K integer representing carrying capacity.
#' @return pop with reduced individuals.
pop_control <- function(pop, K){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    is.numeric(K),
    K%%1==0
  )
  # for every cell
  for(i in 1:nrow(pop)){
    # double check N > K
    plants_in_cell <- pop$plants[i][[1]]
    if(nrow(plants_in_cell) > K){
      # randomly sample K survivors
      survivors <- sample_n(plants_in_cell, K)
      pop$plants[i][[1]] <- survivors
    }
  }
  # recalculate N
  pop <- pop %>% unnest %>% nest_by_location()
  return(pop)
}

#' @name grow
#' @details Change size and number of plants based on growth rate determined via loci of genome.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param type character string defining type of growth. Can be "individuals" or "clones".
#' @param clonal_size number representing size threshold for clonal growth.
#' @param loci a vector of locus IDs for the alleles that define growth rate.
#' @return pop with updated sizes.
grow <- function(
  pop,
  type = "individuals",
  clonal_size = 1
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    "size" %in% colnames(pop),
    "genome" %in% colnames(pop),
    is.character(type),
    type %in% c("individuals", "clones")
  )
  if(type == "individuals"){
    # decide how much plants grow
    growth_rates <- 1:nrow(pop)
    for(plant in 1:nrow(pop)){
      growth_rates[plant] <- pop$genome[[plant]] %>%
        get_growth_rate() %>%
        round(3)
    }
    message("  Growth rate ranges from ", min(growth_rates), " to ", max(growth_rates))
    # do some growing
    pop$size <- round(pop$size * growth_rates, 3)
  } else {
    # make sure we have clonal growth threshold
    stopifnot(
      is.numeric(clonal_size),
      all(pop$size >= clonal_size)
    )
    # do some cloning
    # only size is changed as clones are genetically identical
    # and remain in the same landscape cell
    clones <- pop %>% mutate(
      size = 1 # clones are same size as new seedlings
    )
    pop <- bind_rows(pop, clones)
    # recalculate N (so it counts ramets)
    pop <- pop %>% nest_by_location() %>% unnest()
  }
  return(pop)
}

#' @name germinate
#' @details Change life stage from seed to seedling based on probability. New seeds will have a size of 0.1.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of germination.
#' @return pop with updated life stages and sizes.
germinate <- function(pop, prob = .5){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(prob),
    between(prob, 0, 1)
  )
  # decide which seeds germinate
  pop$life_stage <- rbinom(nrow(pop), 1, prob)
  # increase size of new seedlings so growth can work
  seeds <- pop %>% filter(
    life_stage == 0
  )
  seedlings <- pop %>% filter(
    life_stage == 1
  ) %>% mutate(
    size = 1
  )
  pop <- bind_rows(seeds, seedlings)
  return(pop)
}

#' @name survive
#' @details Reduces population data based on probability of survival.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of survival.
#' @return pop minus deaths
survive <- function(pop, prob = 1){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(prob)
    #all(between(prob, 0, 1))
  )
  # decide which plants die
  deaths <- rbinom(nrow(pop), 1, prob) == 0
  if(!length(which(deaths)) == 0){
    # only attempt removals if there are deaths
    pop <- pop[-which(deaths), ]
  }
  return(pop)
}

#' @name select
#' @details hard selection based on trait values. Large trait values give higher survival probabilities.
#' @author Rose McKeon
#' @param pop A population dataframe
#' @param trait A character string matching a column name which contains trait values.
#' @param Z a constant used to turn trait values into probabilities.
#' @return pop reduced based on survival probabilities created from trait values.
select <- function(pop, trait, Z = 0.001){
  # make sure we have the right parameters
  stopifnot(
    is.data.frame(pop),
    is.character(trait),
    trait %in% colnames(pop)
  )
  # get the trait values in size order
  trait_values <- pop[[trait]] %>% sort()
  # calculate probability of survival
  prob <- 1 - exp(-Z * trait_values)
  return(survive(pop, prob))
}



#' @name move
#' @details updates coordinate variables of a population dataframe as generated by populate_landscape(), ie: should be nested by plant. Movement has wrapping boundaries depending on grid size.
#' @author Rose McKeon
#' @param pop population dataframe nested by plant
#' @param grid_size integer, defines edges at which point movements wrap to the opposite side.
#' @return pop with adjusted X and Y for every row.
#' @usage pop <- populate_landscape(); pop; move(pop);
move <- function(pop, grid_size = 100){
  # error handling
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(grid_size),
    grid_size%%1==0
  )
  # define movement range to sample from
  # made this explicit as mutate method of movement
  # didn't like replacement values based on X or Y
  # (ended up with vectors instead of single numbers).
  movement <- -1:1
  # make the movement
  pop <- pop %>% mutate(
    X = X + sample(movement, size = 1),
    Y = Y + sample(movement, size = 1)
  )
  # make sure boundaries wrap
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X < 1), # only where this is true
      grid_size
    ),
    Y = replace(
      Y,
      which(Y < 1), # only where this is true
      grid_size
    )
  )
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X > grid_size), # only where this is true
      1
    ),
    Y = replace(
      Y,
      which(Y > grid_size), # only where this is true
      1
    )
  )
  return(pop)
}

#' @name populate_landscape
#' @details Populates the landscape grid with individuals
#' @author Rose McKeon
#' @param pop_size integer value for number of starting individuals
#' @param grid_size integer value for size of landscape grid
#' @return list of individuals and their relevant data objects (location and genome)
#' @usage populate_landscape(100, 100)
populate_landscape <- function(
  pop_size = 100,
  grid_size = 100,
  genome_size = 10
){
  # error handling
  stopifnot(
    is.numeric(pop_size),
    pop_size%%1==0,
    is.numeric(grid_size),
    grid_size%%1==0,
    is.numeric(genome_size),
    genome_size%%1==0
  )
  # setup population
  pop <- create_pop(pop_size, grid_size)
  # create genome list-column
  pop <- nest_by_plant(pop)
  # add unique genomes
  for(individual in 1:pop_size){
    pop$genome[[individual]] <- create_genome(genome_size)
  }
  # add density info
  pop <- nest_by_location(pop)
  # return population nested at plant level
  return(unnest(pop))
}


#' @name nest_by_location
#' @details Reorganises population dataframe generated within populate_landscape() so that it is further nested by landscape cell and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame with nested genomes
#' @return Dataframe grouped and nested by coordinates, arranged by population density in descending order.
#' @usage nest_by_location(populate_landscape())
nest_by_location <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0
  )
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    # either with N
    pop <- pop %>% group_by(
      X, Y, N
    )
  } else {
    # or without
    pop <- pop %>% group_by(
      X, Y
    )
  }
  # nest by location
  pop <- pop %>% nest(
    .key = "plants"
  )
  # then create or recalculate N to include density tally
  pop$N <- pop$plants %>%
    map("ID") %>%
    lengths
  # and sort by density
  pop <- pop %>%
    arrange(desc(N))
  return(pop)
}

#' @name nest_by_plant
#' @details Reorganises population dataframe generated within populate_landscape() so that it is nested by plant ID and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame without nested genomes
#' @return Dataframe grouped by individual parameters with nested genomes.
#' @usage nest_by_location(populate_landscape())
nest_by_plant <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0
  )
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    pop <- pop %>% group_by(
      ID, X, Y, N, life_stage, size
    )
  } else {
    pop <- pop %>% group_by(
      ID, X, Y, life_stage, size
    )
  }
  # collapse by plant grouping
  # to make genome data nested in list-column
  pop <- pop %>% nest(
    .key = "genome"
  )
  return(pop)
}

#' @name create_pop
#' @details Makes sure the population structure is always the same. Can be used to return an empty tibble (with no parameters supplied), or a generated population (if both parameters supplied).
#' @author Rose McKeon
#' @param pop_size the number of rows to populate dataframe with.
#' @param grid_size the upper limit of landscape coordinates.
#' @return Either an empty population dataframe with all required columns, or a filled population dataframe depending on supplied parameters.
#' @usage create_pop(); create_pop(100, 10);
create_pop <- function(pop_size = NULL, grid_size = NULL){
  if(!is.null(pop_size) & !is.null(grid_size)){
    # make sure we have numbers
    stopifnot(
      is.numeric(pop_size),
      pop_size%%1==0,
      is.numeric(grid_size),
      grid_size%%1==0
    )
    # generate starting population
    return(
      tibble(
        X = sample(1:grid_size, pop_size, replace = T),
        Y = sample(1:grid_size, pop_size, replace = T),
        ID = paste0("0_", as.character(1:pop_size)),
        life_stage = as.integer(0),
        size = as.integer(0)
      )
    )
  } else {
    # create empty table
    return(
      tibble(
        X = integer(),
        Y = integer(),
        ID = character(),
        life_stage = integer(),
        size = double()
      )
    )
  }
}

#' @name create_genome
#' @details Creates diploid genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of loci in genome
#' @return Data frame containing a diploid genome, with 2 alleles for each locus and number of loci determined by genome_size. Data in long format with $allele and $locus as factors and $value being a random uniform number between 0 and 100.
#' @usage create_genome()
create_genome <- function(
  genome_size = 10
){
  stopifnot(
    is.numeric(genome_size),
    genome_size%%1==0
  )
  # create random genome
  genome <- tibble(
    allele = as.factor(c(
      rep(1, genome_size),
      rep(2, genome_size)
    )),
    locus = as.factor(c(
      rep(1:genome_size, 2)
    )),
    value = runif(
      genome_size*2, 0, 100
    )
  )
  return(genome)
}

#' @name sample_genome
#' @details Takes a vector of seed data that has parent IDs in the genome instead of alleles, and returns a genome of alleles which has been sampled from both parents.
#' @author Rose McKeon
#' @param seed vector of seed data with mum and dad columns nested in genome list-column.
#' @param parents population dataframe containing all possible parents.
#' @param genome Default genome as output by create_genome().
#' @return genome with value filled by sampling parent genomes, defined by parent IDs in seed.
sample_genome <- function(
  seed,
  parents = NULL,
  genome = NULL,
  genome_size = 10,
  ploidy_prob = .01
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(seed$genome),
    "mum" %in% colnames(seed$genome),
    "dad" %in% colnames(seed$genome),
    is.data.frame(parents),
    "ID" %in% colnames(parents),
    "genome" %in% colnames(parents),
    is.data.frame(genome),
    "allele" %in% colnames(genome),
    "locus" %in% colnames(genome),
    "value" %in% colnames(genome),
    is.numeric(genome_size),
    genome_size%%1==0,
    is.numeric(ploidy_prob),
    between(ploidy_prob, 0, 1)
  )
  # extract parents of seed
  parent_IDs <- seed$genome %>%
    gather() %>% pull(value)

  # decide if parents made unreduced gametes
  ploidy <- rbinom(length(parent_IDs), 1, ploidy_prob) == 1

  values <- NULL
  # get the genome of every parent
  for(parent in 1:length(parent_IDs)){
    # if multiple ramets available only one genome should
    # be returned as all are named the same
    parent_genome <- parents$genome[[parent_IDs[parent]]]
    stopifnot(
      is.data.frame(parent_genome),
      "allele" %in% colnames(parent_genome),
      "locus" %in% colnames(parent_genome),
      "value" %in% colnames(parent_genome)
    )
    # check for ploidy
    if(ploidy[parent]){
      # duplicate entire parent genome
      values <- c(
        values,
        parent_genome$value
      )
    } else {
      # nest so every locus is on a row
      parent_genome <- parent_genome %>%
        group_by(locus) %>%
        nest()
      # then sample an allele from each locus
      values <- c(
        values, # add to any alleles of first parent if second
        apply(parent_genome, 1, choose_alleles)
      )
    }
  }
  # make sure alleles is the expected length
  if(length(values) == nrow(genome)){
    # update genome values
    genome$value <- values
  } else {
    # ploidy happened and we need to rebuild the genome
    ploidy_lvl <- length(values) / genome_size
    # can I do this without a loop?
    alleles <- NULL
    for(allele in 1:ploidy_lvl){
      alleles <- c(
        alleles,
        rep(allele, genome_size)
      )
    }
    # we should be ready to fill the dataframe now
    stopifnot(
      length(alleles) == length(values)
    )
    genome <- tibble(
      allele = as.factor(alleles),
      locus = as.factor(rep(1:genome_size, ploidy_lvl)),
      value = values
    )
    message("  *Genome duplication occured*")
  }
  return(genome)
}
