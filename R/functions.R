# functions for the model

#' @name get_plants
#' @details Extracts life stage, size and location data by plant ID from population lists generated by populate_landscape().
#' @author Rose McKeon
#' @param pop population list generated by population_landscape().
#' @return dataframe containing the population with reduced data, columns: ID, stage, size, X_coord, and Y_coord (grouped by coordinates for easy nesting).
#' @usage get_plants(populate_landscape())
get_plants <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(is.list(pop))
  # extract life stage and size data
  plants <- map_dfr(
    pop,
    extract, c(
      "life_stage",
      "size",
      "X_coord",
      "Y_coord"
    ),
    .id = "ID"
  ) %>% group_by(
    X_coord, Y_coord
  )
  # make sure IDs are numeric
  plants$ID <- as.numeric(plants$ID)
  return(plants)
}

#' @name organise_plants_by_cell
#' @details Reorganises dataframe generated by get_plants() so that it is nested by landscape cell and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame as generated by get_plants().
#' @return Dataframe grouped and nested by coordinates, arranged by population density in descending order.
#' @usage organise_plants_by_cell(get_plants(populate_landscape()))
organise_plants_by_cell <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(is.data.frame(pop))
  # collapse by location grouping
  # to make vectors of IDs with matching locations
  plants_by_cell <- pop %>% nest(
    .key = "plants"
  )
  # and enable density tally
  plants_by_cell$N <- plants_by_cell$plants %>%
    map("ID") %>%
    lengths
  # sort and group output locations by density
  plants_by_cell <- plants_by_cell %>%
    arrange(desc(N)) %>%
    group_by(N)

  return(plants_by_cell)
}

#' @name survive
#' @details Reduces a population list based on probability of survival.
#' @author Rose McKeon
#' @param X a list containing population data as generated by populate_landscape().
#' @param probability a number between 0 and 1 representing probability of survival.
#' @return X minus deaths
survive <- function(X, prob = 1){
  # make sure we have the right kind of parameters
  stopifnot(is.list(X) | is.numeric(prob) | between(prob, 0, 1))
  # decide which plants survive
  survivors <- rbinom(length(X), 1, prob)
  survivors <- X[-which(survivors == 0)]
  return(survivors)
}

#' @name move
#' @details Takes a list containing a number (ie: a coordinate) and alters it based on range. Numbers conatined in X will be added to a random number, sampled from the vector -range:range.
#' @author Rose McKeon
#' @param X a list of 1 containing a coordinate.
#' @param range maximum dispersal distance.
#' @return a list in the same format as X containing the adjusted coordinate.
#' @usage
#' # change the number 5 by adding a random number sampled from -1:1
#' move(list(X = 5), 1)
#' # change all nested elements named "X_coord" and "Y_coord" of individuals created by populate_landscape() by adding a random number sampled from -1:1
#' lapply(populate_landscape(), lmap_at, "X_coord", move, 1)
move <- function(X, range = 1, grid_size = 100){
  # make sure we have a list
  stopifnot(is.list(X))
  # and a number for range
  stopifnot(is.numeric(range))
  # define the range to sample from
  movement <- -range:range
  # make the movement
  new_coord <- X[[1]] + sample(movement, size = 1, replace = T)
  # make sure boundaries wrap
  if(new_coord < 0){
    new_coord <- grid_size + (1 + new_coord)
  } else if(new_coord > grid_size){
    new_coord <- -1 + (new_coord - grid_size)
  }
  # return the coordinate in a list with the same names
  out <- list()
  out[[names(X)]] <- new_coord
  return(out)
}

#' @name populate_landscape
#' @details Populates the landscape grid with individuals
#' @author Rose McKeon
#' @param pop_size integer value for number of starting individuals
#' @param grid_size integer value for size of landscape grid
#' @return list of individuals and their relevant data objects (location and genome)
#' @usage populate_landscape(100, 100)
populate_landscape <- function(
  pop_size = 100,
  grid_size = 100
){
  # error handling
  stopifnot(is.numeric(pop_size) & is.numeric(grid_size))
  if(!pop_size%%1==0 | !grid_size%%1==0){
    stop("Please make sure neither pop_size or grid_size contain decimals.")
  }
  # setup landscape vector
  grid <- 1:grid_size
  # setup population
  pop <- list()
  for(i in 1:pop_size){
    ID <- i
    pop[[ID]] <- list()
    pop[[ID]]$X_coord <- sample(grid, 1)
    pop[[ID]]$Y_coord <- sample(grid, 1)
    pop[[ID]]$life_stage <- 0 # 0 = seed, 1 = seedling, 2 = adult
    pop[[ID]]$size <- 0 # starting size
    pop[[ID]]$growth_rate <- 1:10 # refers to rows of genome
    pop[[ID]]$genome <- create_genome()
  }
  return(pop)
}

#' @name create_genome
#' @details Creates dipload genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of alleles in genome
#' @return data frame of length genome_size with 2 columns representing alelle pairs.
#' @usage create_genome()
create_genome <- function(genome_size = 100){
  return <- data.frame(
    A1 = runif(genome_size, 0, 100),
    A2 = runif(genome_size, 0, 100)
  )
}