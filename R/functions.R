#' @name reproduce
#' @details creates new seeds based on adult population.
#' @author Rose McKeon
#' @param pop population dataframe as generated by populate_landscape, subset by life stage = 2 (adults).
#' @param N_gametes number of male and female gametes each adult will create.
#' @param pollen_finds_ova_prob number between 0 and 1 representing probability that pollen released will find ova.
#' @param total_pop_size integer representing whole population size (ie: including seeds and seedlings). Used to give new seeds IDs.
reproduce <- function(
  pop,
  N_gametes = 100,
  pollen_finds_ova_prob = .5,
  generation = 1
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    "life_stage" %in% colnames(pop),
    all(pop$life_stage == 2),
    is.numeric(N_gametes),
    N_gametes%%1==0,
    is.numeric(pollen_finds_ova_prob),
    between(pollen_finds_ova_prob, 0, 1),
    is.numeric(generation),
    generation%%1==0
  )
  pop_in <- pop
  # prepare a new table with gametes instead of genomes
  pop_out <- tibble(
    X = integer(),
    Y = integer(),
    N = integer(),
    ID = integer(),
    life_stage = double(), # why not integer?
    size = double(),
    gametes = list()
  )
  for(adult in 1:nrow(pop)){
    # update the table for every plant
    pop_out <- bind_rows(
      pop_out,
      create_gametes(
        pop_in[adult, ], N_gametes
      )
    )
  }
  # pollination occurs within cells
  # so group population by landscape cell
  pop_out <- pop_out %>% nest_by_location()
  # and prepare new seed and zygote table
  #seeds <- pop_structure %>% select(-gametes)
  seeds <- tibble(
    X = integer(),
    Y = integer(),
    ova = list(),
    pollen = list()
  )
  for(location in 1:nrow(pop_out)){
    # gather all gametes together
    gametes <- pop_out$plants[location][[1]] %>%
      select(gametes) %>%
      unnest()
    # fertilisation
    # (not all pollen is successful)
    zygotes <- pair_gametes(
      gametes, pollen_finds_ova_prob
    )
    # check for complete pollen loss
    if(!is.logical(zygotes)){
      # if some success continue
      if(nrow(zygotes) > 0){
        # add location data
        zygotes <- zygotes %>% add_column(
          X = pop_out$X[location],
          Y = pop_out$Y[location]
        )
        # store as seeds
        seeds <- bind_rows(
          seeds, zygotes
        )
      }
    }
  }
  if(nrow(seeds) > 0){
    # add other usual population data
    seeds <- seeds %>% add_column(
      ID = paste0(generation, "_", 1:nrow(seeds)),
      life_stage = as.integer(0),
      size = as.integer(0)
    )
    seeds <- nest_by_plant(seeds)
    # restructure genomes
    for(seed in 1:nrow(seeds)){
      genome <- seeds$genome[seed][[1]]
      # make the columns named correctly
      genome <- genome %>% rename(allele_1 = ova)
      genome <- genome %>% rename(allele_2 = pollen)
      # and unpack the alleles
      genome <- genome %>% unnest()
      genome <- genome %>% add_column(
        locus = 1:nrow(genome),
        .before = "allele_1"
      )
      seeds$genome[seed][[1]] <- genome
    }
    return(seeds)
  } else {
    return(F)
  }
}

#' @name pair_gametes
#' @details Pairs pollen with ova when given a dataframe of gametes. Pollen numbers reduced by probability of finding an ova, then ova are assigned to pollen with replacement to allow for pollen competition. Any competing pollen have a random winner selected.
#' @author Rose McKeon
#' @param gametes dataframe of unnested gametes from adult populaton that has had gametes created with create_gametes().
#' @param prob number between 0 and 1 representing the probability that pollen will land on an ova.
#' @return dataframe of paired ova and pollen as list-columns containing genetic information. This output represents zygotes.
pair_gametes <- function(gametes, prob){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(gametes),
    nrow(gametes) > 0,
    "ova" %in% colnames(gametes),
    "pollen" %in% colnames(gametes),
    is.numeric(prob),
    between(prob, 0, 1)
  )
  # separate gametes and make sure some pollen is lost
  ova <- gametes %>% select(ova)
  pollen <- gametes %>% select(pollen) %>% survive(prob)
  # make sure we still have pollen
  if(nrow(pollen) > 0){
    # assign ova to pollen with replacement as
    # pollen grains could land on the same ova
    ova_IDs <- sample(1:nrow(ova), nrow(pollen), replace = T)
    pollen <- pollen %>% add_column(
      ova = ova[ova_IDs, ] %>% pull(ova),
      ova_ID = ova_IDs
    )
    # find out if we have pollen competition
    pollen <- pollen %>% group_by(ova_ID) %>% nest(.key = "gametes")
    pollen$N <- pollen$gametes %>%
      map("pollen") %>%
      lengths
    # if no competition store zygotes
    winners <- pollen %>% filter(N < 2)
    if(nrow(winners) > 0){
      zygotes <- winners %>% unnest() %>% select(ova, pollen)
    } else {
      zygotes <- winners # empty row to bind on to
    }
    # if competition, choose winner
    competitors <- pollen %>% filter(N > 1)
    if(nrow(competitors) > 0){
      for(contest in 1:nrow(competitors)){
        # for every contest randomly sample 1 pollen row to keep
        competitors$gametes[contest][[1]] <- sample_n(
          competitors$gametes[contest][[1]], 1
        )
      }
      winners <- competitors %>% unnest() %>% select(ova, pollen)
      # then store zgotes
      zygotes <- bind_rows(
        zygotes, winners
      )
    }
    return(zygotes)
  } else {
    return(F)
  }
}


#' @name choose_alleles
#' @details Creates a vector of alleles based on a parent genome. An allele value is chosen at random from each row of the genome to create a vector with length equal to rows of parent genome. Used by create_gametes() to give each gamete varied, but still inherited, genetic material.
#' @author Rose McKeon
#' @param genome A dataframe containing the genome of an individual.
#' @return a vector of alleles.
choose_alleles <- function(genome){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(genome),
    "locus" %in% colnames(genome),
    # need atleast one set of alleles
    "allele_1" %in% colnames(genome)
  )
  # isolate the alelles
  genome <- genome %>% select(-locus)
  # prepare an empty vector
  alleles <- NULL
  # for every row, gather all alleles present
  # then sample one value from that vector
  for(locus in 1:nrow(genome)){
    alleles[locus] <- sample(
      gather(genome[locus, ])$value, 1
    )
  }
  return(alleles)
}


#' @name create_gametes
#' @details Replaces the genome list-column of an individual plant with a gametes list-column. Gametes contains ova and pollen created by randomly choosing between allele pairs at each loci of the parent genome.
#' @author Rose McKeon
#' @param plant A single row of a population dataframe as generated by populate_landscape. Should also be an adult (life stage == 2).
#' @param N integer representing the number of gametes of each kind to make. There will be N ova and N pollen created.
#' @return plant with genome list-column replaced by new gametes list-column.
create_gametes <- function(plant, N = 500){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(plant),
    "genome" %in% colnames(plant),
    "life_stage" %in% colnames(plant),
    all(plant$life_stage == 2),
    is.numeric(N),
    N%%1==0
  )
  genome <- plant$genome[[1]]
  # prepare a table for the gametes
  gametes <- tibble(
    ova = list(),
    pollen = list()
  )
  # make sure each gamete randomly assigns alelles
  # from the choice available at each locus
  # (haploid gametes created from diploid genome)
  for(gamete in 1:N){
    gametes[gamete, ]$ova <- list(
      allele = choose_alleles(genome)
    )
    gametes[gamete, ]$pollen <- list(
      allele = choose_alleles(genome)
    )
  }
  # add the gametes to the parent plant
  # remove genome now as only gametes required
  # (won't unnest otherwise unless dimensions
  # of genome and gametes are the same).
  plant <- plant %>% add_column(
    gametes = list(gametes)
  ) %>% select(-genome)
  return(plant)
}

#' @name pop_control
#' @details Randomly reduces population size of landscape cells based on carrying capacity (maximum number of plants per cell).
#' @author Rose McKeon
#' @param pop poplation dataframe nested by location.
#' @param K integer representing carrying capacity.
#' @return pop with reduced individuals.
pop_control <- function(pop, K){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    is.numeric(K),
    K%%1==0
  )
  # for every cell
  for(i in 1:nrow(pop)){
    # double check N > K
    plants_in_cell <- pop$plants[i][[1]]
    if(nrow(plants_in_cell) > K){
      # randomly sample K survivors
      survivors <- sample_n(plants_in_cell, K)
      pop$plants[i][[1]] <- survivors
    }
  }
  # recalculate N
  pop <- pop %>% unnest %>% nest_by_location()
  return(pop)
}

#' @name grow
#' @details Change size and number of plants based on growth rate determined via loci of genome.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param type character string defining type of growth. Can be "individuals" or "clones".
#' @param clonal_size number representing size threshold for clonal growth.
#' @param loci a vector of locus IDs for the alleles that define growth rate.
#' @return pop with updated sizes.
grow <- function(
  pop,
  type = "individuals",
  clonal_size = 1,
  loci = 1:10
){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.character(type),
    type %in% c("individuals", "clones"),
    is.numeric(loci)
  )
  if(type == "individuals"){
    # decide how much plants grow
    growth_rates <- numeric()
    for(i in 1:nrow(pop)){
      growth_rates[i] <- pop$genome[[i]][loci, ] %>% select(
        -locus
      ) %>% sum() / 100
    }
    # do some growing
    pop$size <- pop$size * growth_rates
  } else {
    # make sure we have clonal growth threshold
    stopifnot(
      is.numeric(clonal_size)
    )
    # do some cloning
    # only size is changed as clones are genetically identical
    # and remain in the same landscape cell
    clones <- pop %>% mutate(
      size = size / 2 # clones are half the size
    )
    if(max(clones$size) > clonal_size){
      # biggest plants clone again
      # tried a while loop here but it crashes
      big_clones <- clones %>% filter(size >= clonal_size)
      clones <- bind_rows(
        clones,
        big_clones %>% mutate(
          size = size / 2
        )
      )
    }
    pop <- bind_rows(pop, clones)
    # recalculate N (so it counts ramets)
    pop <- pop %>% nest_by_location() %>% unnest()
  }
  return(pop)
}

#' @name germinate
#' @details Change life stage from seed to seedling based on probability. New seeds will have a size of 0.1.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of germination.
#' @return pop with updated life stages and sizes.
germinate <- function(pop, prob = .5){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(prob),
    between(prob, 0, 1)
  )
  # decide which seeds germinate
  pop$life_stage <- rbinom(nrow(pop), 1, prob)
  # increase size of new seedlings so growth can work
  seeds <- pop %>% filter(
    life_stage == 0
  )
  seedlings <- pop %>% filter(
    life_stage == 1
  ) %>% mutate(
    size = 0.1
  )
  pop <- bind_rows(seeds, seedlings)
  return(pop)
}

#' @name survive
#' @details Reduces population data based on probability of survival.
#' @author Rose McKeon
#' @param pop a population dataframe as generated by populate_landscape(), ie: nested by plant.
#' @param probability a number between 0 and 1 representing probability of survival.
#' @return pop minus deaths
survive <- function(pop, prob = 1){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(prob),
    between(prob, 0, 1)
  )
  # decide which plants die
  deaths <- rbinom(nrow(pop), 1, prob) == 0
  if(!length(which(deaths)) == 0){
    # only attempt removals if there are deaths
    pop <- pop[-which(deaths), ]
  }
  return(pop)
}

#' @name move
#' @details updates coordinate variables of a population dataframe as generated by populate_landscape(), ie: should be nested by plant. Movement has wrapping boundaries depending on grid size.
#' @author Rose McKeon
#' @param pop population dataframe nested by plant
#' @param grid_size integer, defines edges at which point movements wrap to the opposite side.
#' @return pop with adjusted X and Y for every row.
#' @usage pop <- populate_landscape(); pop; move(pop);
move <- function(pop, grid_size = 100){
  # error handling
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0,
    is.numeric(grid_size),
    grid_size%%1==0
  )
  # define movement range to sample from
  # made this explicit as mutate method of movement
  # didn't like replacement values based on X or Y
  # (ended up with vectors instead of single numbers).
  movement <- -1:1
  # make the movement
  pop <- pop %>% mutate(
    X = X + sample(movement, size = 1),
    Y = Y + sample(movement, size = 1)
  )
  # make sure boundaries wrap
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X < 1), # only where this is true
      grid_size
    ),
    Y = replace(
      Y,
      which(Y < 1), # only where this is true
      grid_size
    )
  )
  pop <- pop %>% mutate(
    X = replace(
      X,
      which(X > grid_size), # only where this is true
      1
    ),
    Y = replace(
      Y,
      which(Y > grid_size), # only where this is true
      1
    )
  )
  return(pop)
}

#' @name populate_landscape
#' @details Populates the landscape grid with individuals
#' @author Rose McKeon
#' @param pop_size integer value for number of starting individuals
#' @param grid_size integer value for size of landscape grid
#' @return list of individuals and their relevant data objects (location and genome)
#' @usage populate_landscape(100, 100)
populate_landscape <- function(
  pop_size = 100,
  grid_size = 100,
  genome_size = 100
){
  # error handling
  stopifnot(
    is.numeric(pop_size),
    pop_size%%1==0,
    is.numeric(grid_size),
    grid_size%%1==0,
    is.numeric(genome_size),
    genome_size%%1==0
  )
  # setup population
  pop <- tibble(
    ID = 1:pop_size,
    X = sample(1:grid_size, pop_size, replace = T),
    Y = sample(1:grid_size, pop_size, replace = T),
    life_stage = as.integer(0),
    size = as.integer(0)
  )
  pop <- nest_by_plant(pop)
  # add unique genomes
  for(i in 1:pop_size){
    pop$genome[[i]] <- create_genome(genome_size)
  }
  # add density info
  pop <- nest_by_location(pop)
  # return population nested at plant level
  return(unnest(pop))
}


#' @name nest_by_location
#' @details Reorganises population dataframe generated within populate_landscape() so that it is further nested by landscape cell and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame with nested genomes
#' @return Dataframe grouped and nested by coordinates, arranged by population density in descending order.
#' @usage nest_by_location(populate_landscape())
nest_by_location <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0
  )
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    # either with N
    pop <- pop %>% group_by(
      X, Y, N
    )
  } else {
    # or without
    pop <- pop %>% group_by(
      X, Y
    )
  }
  # nest by location
  pop <- pop %>% nest(
    .key = "plants"
  )
  # then create or recalculate N to include density tally
  pop$N <- pop$plants %>%
    map("ID") %>%
    lengths
  # and sort by density
  pop <- pop %>%
    arrange(desc(N))
  return(pop)
}

#' @name nest_by_plant
#' @details Reorganises population dataframe generated within populate_landscape() so that it is nested by plant ID and sorted in descending order of landscape cell population size.
#' @author Rose McKeon
#' @param pop population data frame without nested genomes
#' @return Dataframe grouped by individual parameters with nested genomes.
#' @usage nest_by_location(populate_landscape())
nest_by_plant <- function(pop){
  # make sure we have the right kind of parameters
  stopifnot(
    is.data.frame(pop),
    nrow(pop) > 0
  )
  # group differently depending on pop columns
  if("N" %in% colnames(pop)){
    pop <- pop %>% group_by(
      ID, X, Y, N, life_stage, size
    )
  } else {
    pop <- pop %>% group_by(
      ID, X, Y, life_stage, size
    )
  }
  # collapse by plant grouping
  # to make genome data nested in list-column
  pop <- pop %>% nest(
    .key = "genome"
  )
  return(pop)
}

#' @name create_genome
#' @details Creates dipload genomes using random numbers.
#' @author Rose McKeon
#' @param genome_size integer value for number of alleles in genome
#' @return data frame of length genome_size with 2 columns representing alelle pairs.
#' @usage create_genome()
create_genome <- function(genome_size = 100){
  stopifnot(
    is.numeric(genome_size),
    genome_size%%1==0
  )
  return(tibble(
    locus = 1:genome_size,
    allele_1 = runif(genome_size, 0, 100),
    allele_2 = runif(genome_size, 0, 100)
  ))
}
